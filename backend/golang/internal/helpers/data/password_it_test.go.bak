package data

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"testing"

	"github.com/myfusionhelper/api/internal/connectors"
	"github.com/myfusionhelper/api/internal/helpers"
)

type mockConnectorForPassword struct {
	fieldValues   map[string]interface{}
	updatedFields map[string]interface{}
}

func (m *mockConnectorForPassword) GetContactFieldValue(ctx context.Context, contactID, fieldKey string) (interface{}, error) {
	if m.fieldValues == nil {
		return nil, nil
	}
	val, ok := m.fieldValues[fieldKey]
	if !ok {
		return nil, nil
	}
	return val, nil
}

func (m *mockConnectorForPassword) SetContactFieldValue(ctx context.Context, contactID, fieldKey string, value interface{}) error {
	if m.updatedFields == nil {
		m.updatedFields = make(map[string]interface{})
	}
	m.updatedFields[fieldKey] = value
	return nil
}

func (m *mockConnectorForPassword) GetContact(ctx context.Context, contactID string) (*connectors.NormalizedContact, error) {
	return nil, fmt.Errorf("not implemented")
}
func (m *mockConnectorForPassword) GetContacts(ctx context.Context, opts connectors.QueryOptions) (*connectors.ContactList, error) {
	return nil, fmt.Errorf("not implemented")
}
func (m *mockConnectorForPassword) CreateContact(ctx context.Context, input connectors.CreateContactInput) (*connectors.NormalizedContact, error) {
	return nil, fmt.Errorf("not implemented")
}
func (m *mockConnectorForPassword) UpdateContact(ctx context.Context, contactID string, updates connectors.UpdateContactInput) (*connectors.NormalizedContact, error) {
	return nil, fmt.Errorf("not implemented")
}
func (m *mockConnectorForPassword) DeleteContact(ctx context.Context, contactID string) error {
	return fmt.Errorf("not implemented")
}
func (m *mockConnectorForPassword) GetTags(ctx context.Context) ([]connectors.Tag, error) {
	return nil, fmt.Errorf("not implemented")
}
func (m *mockConnectorForPassword) ApplyTag(ctx context.Context, contactID, tagID string) error {
	return fmt.Errorf("not implemented")
}
func (m *mockConnectorForPassword) RemoveTag(ctx context.Context, contactID, tagID string) error {
	return fmt.Errorf("not implemented")
}
func (m *mockConnectorForPassword) GetCustomFields(ctx context.Context) ([]connectors.CustomField, error) {
	return nil, fmt.Errorf("not implemented")
}
func (m *mockConnectorForPassword) TriggerAutomation(ctx context.Context, contactID, automationID string) error {
	return fmt.Errorf("not implemented")
}
func (m *mockConnectorForPassword) AchieveGoal(ctx context.Context, contactID, goalName, integration string) error {
	return fmt.Errorf("not implemented")
}
func (m *mockConnectorForPassword) TestConnection(ctx context.Context) error {
	return nil
}
func (m *mockConnectorForPassword) GetMetadata() connectors.ConnectorMetadata {
	return connectors.ConnectorMetadata{}
}
func (m *mockConnectorForPassword) GetCapabilities() []connectors.Capability {
	return nil
}

func TestPasswordIt_Metadata(t *testing.T) {
	helper := &PasswordIt{}
	if helper.GetName() != "Password It" {
		t.Errorf("Expected name 'Password It', got '%s'", helper.GetName())
	}
	if helper.GetType() != "password_it" {
		t.Errorf("Expected type 'password_it', got '%s'", helper.GetType())
	}
	if helper.GetCategory() != "data" {
		t.Errorf("Expected category 'data', got '%s'", helper.GetCategory())
	}
}

func TestPasswordIt_ValidateConfig_MissingTargetField(t *testing.T) {
	helper := &PasswordIt{}
	config := map[string]interface{}{
		"length": 16,
	}

	err := helper.ValidateConfig(config)
	if err == nil || !strings.Contains(err.Error(), "target_field") {
		t.Errorf("Expected error about target_field, got: %v", err)
	}
}

func TestPasswordIt_Execute_DefaultLength(t *testing.T) {
	helper := &PasswordIt{}
	mockConn := &mockConnectorForPassword{
		fieldValues: map[string]interface{}{},
	}

	input := helpers.HelperInput{
		ContactID: "123",
		Connector: mockConn,
		Config: map[string]interface{}{
			"target_field": "password",
		},
	}

	_, err := helper.Execute(context.Background(), input)
	if err != nil {
		t.Fatalf("Expected no error, got: %v", err)
	}

	if !output.Success {
		t.Error("Expected success=true")
	}

	password := mockConn.updatedFields["password"].(string)
	if len(password) != 12 {
		t.Errorf("Expected default length 12, got: %d", len(password))
	}
}

func TestPasswordIt_Execute_CustomLength(t *testing.T) {
	helper := &PasswordIt{}
	mockConn := &mockConnectorForPassword{
		fieldValues: map[string]interface{}{},
	}

	input := helpers.HelperInput{
		ContactID: "123",
		Connector: mockConn,
		Config: map[string]interface{}{
			"target_field": "password",
			"length":       20,
		},
	}

	_, err := helper.Execute(context.Background(), input)
	if err != nil {
		t.Fatalf("Expected no error, got: %v", err)
	}

	password := mockConn.updatedFields["password"].(string)
	if len(password) != 20 {
		t.Errorf("Expected length 20, got: %d", len(password))
	}
}

func TestPasswordIt_Execute_WithSpecialChars(t *testing.T) {
	helper := &PasswordIt{}
	mockConn := &mockConnectorForPassword{
		fieldValues: map[string]interface{}{},
	}

	input := helpers.HelperInput{
		ContactID: "123",
		Connector: mockConn,
		Config: map[string]interface{}{
			"target_field":    "password",
			"length":          100,
			"include_special": true,
		},
	}

	_, err := helper.Execute(context.Background(), input)
	if err != nil {
		t.Fatalf("Expected no error, got: %v", err)
	}

	password := mockConn.updatedFields["password"].(string)
	
	// With a long enough password and special chars enabled, should have at least one special char
	hasSpecial := regexp.MustCompile(`[!@#$%^&*()\-_=+\[\]{}|;:,.<>?]`).MatchString(password)
	if !hasSpecial && len(password) >= 100 {
		t.Log("Note: No special characters found in 100-char password (statistically unlikely but possible)")
	}
}

func TestPasswordIt_Execute_WithoutSpecialChars(t *testing.T) {
	helper := &PasswordIt{}
	mockConn := &mockConnectorForPassword{
		fieldValues: map[string]interface{}{},
	}

	input := helpers.HelperInput{
		ContactID: "123",
		Connector: mockConn,
		Config: map[string]interface{}{
			"target_field":    "password",
			"length":          16,
			"include_special": false,
		},
	}

	_, err := helper.Execute(context.Background(), input)
	if err != nil {
		t.Fatalf("Expected no error, got: %v", err)
	}

	password := mockConn.updatedFields["password"].(string)
	
	// Should only contain alphanumeric
	hasSpecial := regexp.MustCompile(`[^a-zA-Z0-9]`).MatchString(password)
	if hasSpecial {
		t.Errorf("Expected no special characters, but found some in: %s", password)
	}
}

func TestPasswordIt_Execute_OverwriteFalse(t *testing.T) {
	helper := &PasswordIt{}
	mockConn := &mockConnectorForPassword{
		fieldValues: map[string]interface{}{
			"password": "existing-password",
		},
	}

	input := helpers.HelperInput{
		ContactID: "123",
		Connector: mockConn,
		Config: map[string]interface{}{
			"target_field": "password",
			"overwrite":    false,
		},
	}

	_, err := helper.Execute(context.Background(), input)
	if err != nil {
		t.Fatalf("Expected no error, got: %v", err)
	}

	if !output.Success {
		t.Error("Expected success=true")
	}

	if !strings.Contains(output.Message, "already has a value") {
		t.Errorf("Expected message about existing value, got: %s", output.Message)
	}

	// Should not have updated the field
	if _, ok := mockConn.updatedFields["password"]; ok {
		t.Error("Should not update field when overwrite=false and value exists")
	}
}

func TestPasswordIt_Execute_OverwriteTrue(t *testing.T) {
	helper := &PasswordIt{}
	mockConn := &mockConnectorForPassword{
		fieldValues: map[string]interface{}{
			"password": "existing-password",
		},
	}

	input := helpers.HelperInput{
		ContactID: "123",
		Connector: mockConn,
		Config: map[string]interface{}{
			"target_field": "password",
			"overwrite":    true,
		},
	}

	_, err := helper.Execute(context.Background(), input)
	if err != nil {
		t.Fatalf("Expected no error, got: %v", err)
	}

	if !output.Success {
		t.Error("Expected success=true")
	}

	// Should have generated a new password
	newPassword := mockConn.updatedFields["password"].(string)
	if newPassword == "existing-password" {
		t.Error("Expected new password to be generated")
	}
	if len(newPassword) != 12 {
		t.Errorf("Expected default length 12, got: %d", len(newPassword))
	}
}

func TestPasswordIt_Execute_ActionLogging(t *testing.T) {
	helper := &PasswordIt{}
	mockConn := &mockConnectorForPassword{
		fieldValues: map[string]interface{}{},
	}

	input := helpers.HelperInput{
		ContactID: "123",
		Connector: mockConn,
		Config: map[string]interface{}{
			"target_field": "password",
			"length":       15,
		},
	}

	_, err := helper.Execute(context.Background(), input)
	if err != nil {
		t.Fatalf("Expected no error, got: %v", err)
	}

	if len(output.Actions) != 1 {
		t.Fatalf("Expected 1 action, got %d", len(output.Actions))
	}

	action := output.Actions[0]
	if action.Type != "field_updated" {
		t.Errorf("Expected action type 'field_updated', got '%s'", action.Type)
	}
	if action.Target != "password" {
		t.Errorf("Expected action target 'password', got '%s'", action.Target)
	}

	if len(output.Logs) == 0 {
		t.Error("Expected logs to be generated")
	}

	if output.ModifiedData == nil {
		t.Fatal("Expected ModifiedData to be set")
	}
}
